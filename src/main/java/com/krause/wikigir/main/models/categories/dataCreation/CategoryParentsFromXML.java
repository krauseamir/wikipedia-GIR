package com.krause.wikigir.main.models.categories.dataCreation;

import com.krause.wikigir.main.Constants;
import com.krause.wikigir.main.models.general.WikiXMLArticlesExtractor;
import com.krause.wikigir.main.models.utils.ExceptionWrapper;
import com.krause.wikigir.main.models.utils.ProgressBar;

import java.util.stream.Collectors;
import java.util.List;
import java.util.Map;

/**
 * Attempts to augment the categories graph generated by {@link CategoryNamesGraph} by iterating over
 * the Wikipedia XML file and extracting category parents from each appearing category's page.
 */
public class CategoryParentsFromXML extends CategoryNamesFromXMLBase
{
    private final Map<String, CategoryNamesGraph.CategoryNode> categoriesMap;

    /**
     * Constructor.
     * @param categoriesMap    a mapping of category names to category graph nodes, as generated
     *                         by {@link CategoryNamesGraph}.
     */
    public CategoryParentsFromXML(Map<String, CategoryNamesGraph.CategoryNode> categoriesMap)
    {
        this.categoriesMap = categoriesMap;
    }

    /**
     * Iterates over the Wikipedia XML file and detects designated categories articles - for each such article,
     * extracts the parent categories as appearing in the xml structure.
     */
    @SuppressWarnings("unchecked")
    public void extract()
    {
        int[] processed = {0};

        WikiXMLArticlesExtractor.extract(getCategoriesParserFactory(),
            (parser, text) ->
                super.executor.execute(() ->
                    ExceptionWrapper.wrap(() ->
                    {
                        ProgressBar.mark(processed, Constants.NUMBER_OF_ARTICLES);
                        parser.parse(text);
                        parser.addTitleToResult(text);

                        synchronized(this.categoriesMap)
                        {
                            if(parser.getTitle().startsWith("Category:"))
                            {
                                String category = parser.getTitle().substring("Category:".length()).trim();

                                // Get all subcategories, avoid a potential situation where the category itself
                                // appears in the supercategories (not sure if it can actually happen).
                                List<String> supers = ((List<String>)parser.getResult().get(CATEGORIES_KEY)).stream()
                                                      .filter(c -> !c.equals(category)).collect(Collectors.toList());

                                CategoryNamesGraph.CategoryNode catNode = this.categoriesMap.get(category);

                                // If there is no such category, only add it if it has at least one valid
                                // (currently existing) supercategory - will prevent "detached" nodes.
                                if(catNode == null)
                                {
                                    boolean found = false;
                                    for(String supercategory : supers)
                                    {
                                        if(this.categoriesMap.containsKey(supercategory))
                                        {
                                            found = true;
                                            break;
                                        }
                                    }

                                    if(!found)
                                    {
                                        return;
                                    }

                                    catNode = new CategoryNamesGraph.CategoryNode(category);
                                    this.categoriesMap.put(category, catNode);
                                }

                                for(String supercategory : supers)
                                {
                                    CategoryNamesGraph.CategoryNode superCatNode = this.categoriesMap.get(supercategory);

                                    if(superCatNode == null)
                                    {
                                        continue;
                                    }

                                    superCatNode.addSubcategory(catNode);
                                    catNode.addSupercategory(superCatNode);
                                }

                            }
                        }
                    })
                ), ARTICLES_LIMIT, true, false);    // Note that we set the "categories" flag to true.
                                                    // (and the redirects flag to false).

        super.executor.waitForTermination();
    }
}